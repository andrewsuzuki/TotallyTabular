/**
 * This Java Class is part of the Impro-Visor Application
 *
 * Copyright (C) 2005-2014 Robert Keller and Harvey Mudd College
 *
 * Impro-Visor is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * Impro-Visor is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of merchantability or fitness
 * for a particular purpose. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Impro-Visor; if not, write to the Free Software Foundation, Inc., 51 Franklin
 * St, Fifth Floor, Boston, MA 02110-1301 USA
 */
package imp.lickgen;

import imp.brickdictionary.Block;
import imp.data.Chord;
import imp.data.ChordPart;
import imp.data.MelodyPart;
import imp.data.Note;
import imp.data.Part.PartIterator;
import imp.gui.Notate;
import static imp.lickgen.Terminals.getDuration;
import static imp.lickgen.Terminals.isTerminal;
import static imp.lickgen.Terminals.isWrappedTerminal;
import imp.util.ErrorLog;
import imp.util.ErrorLogWithResponse;
import java.io.*;
import java.util.ArrayList;
import java.util.Collection;
import polya.Arith;
import polya.Polylist;
import polya.PolylistBuffer;
import polya.PolylistEnum;
import polya.Tokenizer;

/*
 * @author David Morrison, modifications by Robert Keller, 21 June 2012, 
 * revised method by Robert Keller, 1 August 2014
 */
public class Grammar
{
/**
 * Set traceLevel to 1 to see which rules are being applied and also
 * any bricks identified.
 * Set traceLevel to 2 to see frontier of derivation in addition to rules.
 */
int traceLevel = 0;

// Rule tags:
public static final String START = "startsymbol";
public static final String TERMINAL = "terminals";
public static final String BASE = "base";
public static final String RULE = "rule";
public static final String PARAM = "parameter";
public static final String COMMENT = "comment";
// Special forms:
public static final String BUILTIN = "builtin";
public static final String SPLICE = "splice";
public static final String LITERAL = "literal";
// Operators:
public static final String PLUS = "+";
public static final String MINUS = "-";
public static final String TIMES = "*";
public static final String DIVIDE = "/";
// Builtin variables:
public static final String BRICK = "brick";
public static final String CHORD_FAMILY = "chord-family";
public static final String EXPECTANCY = "expectancy";
public static final String SYNCOPATION = "syncopation";
public static final String HIGH = "high";
public static final String MEDIUM = "medium";
public static final String LOW = "low";
public static final Double ONE = new Double(1);
public static final Double ZERO = new Double(0);
//ArrayList<String> terminals = new ArrayList<String>();
Polylist rules = Polylist.nil;
String startSymbol = null; // to be set
private Notate notate;
private int currentSlot;
private int chordSlot;
boolean quotaReached;

public Grammar(String file)
  {
    loadGrammar(file);
  }

/**
 * terminalBuffer contains all terminals generated by the grammar in 
 * one call to run.
 */
PolylistBuffer terminalBuffer;

/**
 * numSlotsToFill keeps track of the number of slots yet to be filled.
 */
int numSlotsToFill;

/**
 * 
 * @param startSlot
 * @param initialNumSlots
 * @param myNotate
 * @param whetherToTrade
 * @param improVisorFirst
 * @param tradingQuantum
 * @return 
 */
public Polylist run(int startSlot,
                    int initialNumSlots,
                    Notate myNotate,
                    boolean whetherToTrade,
                    boolean improVisorFirst,
                    int tradingQuantum)
  {
    currentSlot = startSlot;
    chordSlot = startSlot;
    int totalSlotsToFill = initialNumSlots;
    notate = myNotate;

    terminalBuffer = new PolylistBuffer();
    int stage = 0;

    // Outer loop is for trading, in which melodies are alternating
    // with rests. If not trading, the outer loop will be executed only once.
    
    while( totalSlotsToFill > 0 )
      {
        if( whetherToTrade )
          {
          numSlotsToFill = Math.min(tradingQuantum, totalSlotsToFill); 
          }
        else
          {
          numSlotsToFill = totalSlotsToFill;
          }
        
        quotaReached = numSlotsToFill <= 0;

        // If trading with Impro-Visor first, add a quantum of rests
        // at the beginning, and update the chordSlot accordingly.
        if( whetherToTrade && !improVisorFirst )
          {
            String fillRests = Note.getDurationString(tradingQuantum);
            terminalBuffer.append("R" + fillRests);
            chordSlot += tradingQuantum;
          }

        // Inner loop fills one quantum worth of abstract melody, or the
        // entire abstract melody if not trading.
        
        while( !quotaReached )
          {
            // Start a new stage, with the start symbol and number of slots to fill
            // as the argument on an initial goal.

            try
              {
                stage++;
                Polylist stack = addStart(numSlotsToFill);

                if( stack == null )
                  {
                    return Polylist.nil;    // In case no grammar
                  }

                //System.out.println("\nStage " + stage + " generation starts with " + stack + " terminalBuffer length " + getDurationAbstractMelody(terminalBuffer));

                // stack is a list representing the undeveloped frontier of the rhs tree
                // symbols in stack are expanded one at a time, left-to-right
                // As non-terminal are expanded, the RHS replaces the non-terminal
                // on the left of stack.
                // If the top of stack is a terminal, it is flipped over onto 
                // accumulator, and then appended to terminalBuffer.

                // So the combination of terminalBuffer and stack represent the total
                // frontier of the rhs tree.
                // The variable terminalBuffer is modified implicitly within applyRules.

                while( !quotaReached && stack.nonEmpty() )
                  {
                    // System.out.println("stack = " + stack);  // Shows rhs.
                    stack = applyRules(stack);

                    if( stack == null )
                      {
                        throw new RuleApplicationException();
                      }
                  }

                if( traceLevel > 1 )
                  {
                    showFrontier(stack);
                  }
              }
            catch( RuleApplicationException e )
              {
                if( ErrorLogWithResponse.log(ErrorLog.SEVERE, "Problem applying rules: " + e) )
                  {
                    return null;
                  }
              }
          }

        // If trading, may need to pad with rests at the end of this quantum
        // so that the next one starts in the right place.
        
        if( whetherToTrade )
          {
          // Add rests at the end if Impro-Visor goes first.
          int paddingSlots = numSlotsToFill;
          if( improVisorFirst )
            {
            paddingSlots += tradingQuantum;
            }
          if( paddingSlots > 0 )
            {
            String fillRests = Note.getDurationString(paddingSlots);
            terminalBuffer.append("R" + fillRests);
            chordSlot += paddingSlots;
            }
        //System.out.println("completed in " + stage + " stages" + ". terminalBuffer " + terminalBuffer.toPolylist());
          totalSlotsToFill -= 2 * tradingQuantum;
          }
        else
          {
          totalSlotsToFill = 0;
          }
      }
    // Return the abstract melody, truncated to the desired number of slots.
    // Truncation should not be necessary if everything was done right, but
    // it seems that we go over sometime. Not sure why.
    return Terminals.truncateAbstractMelody(terminalBuffer.toPolylist(), initialNumSlots);

  }

/**
 * Add terminal to the list of terminals generated, as long as the quota has
 * not been reached. Checks whether the terminal would go over quota, and
 * if so, does not add it, but set quotaReached indicator instead.
 * @param terminal 
 */
private void accumulateTerminal(Object terminal)
  {
    if( quotaReached )
      {
        return;
      }
    int duration = getDuration(terminal);
    if( numSlotsToFill < duration )
      {
        quotaReached = true;
        return;
      }
    terminalBuffer.append(terminal);
    chordSlot += duration;
    numSlotsToFill -= duration;
  }

/**
 * Add the Start Symbol to list stack in order to start the grammar expansion.
 */
public Polylist addStart(int numSlots)
  {
    Polylist stack = Polylist.nil;
    Polylist search = rules;

    // While the list of rules isn't empty...
    while( search.nonEmpty() )
      {
        Polylist next = (Polylist) search.first();
        search = search.rest();

        try
          {
            // ... See if the next rule contains the "startsymbol" tag.
            // If it does, token it on the front of the string.
            if( ((String) next.first()).equals(START) )
              {
                if( next.length() == 2 && next.second() instanceof String )
                  {
                    startSymbol = (String) next.second();

                    Polylist s = Polylist.list(startSymbol, numSlots);
                    stack = stack.cons(s);
                    return stack;
                  }
                else
                  {
                    ErrorLog.log(ErrorLog.SEVERE,
                                 "Malformed start rule: " + next + ".  Abort.");
                    return null;
                  }
              }
          }
        // Catch any syntax errors in the rule file.  At some point it might
        // be nice to actually print out what the problem is...
        catch( ClassCastException e )
          {
            ErrorLog.log(ErrorLog.SEVERE, "Malformed rules file.  Abort.");
            return null;
          }
      }

    // If it didn't find a start lhs in the file, abort.
    ErrorLog.log(ErrorLog.SEVERE, "No start symbol found.  Abort.");
    return null;
  }

/**
 * Add a rule to the appropriate list, so that probabilities can be
 * computed and a rule then selected. Only add if the computed value of the
 * weight expression is non-negative.
 *
 * @param lhs left-hand side of the rule
 * @param rhs right-hand side of the rule
 * @param wtExp weight expression of the rule (unevaluated)
 * @param ruleList list to which to add this rule
 */
private void addToList(Polylist lhs, 
                       Polylist rhs, 
                       Object wtExp, 
                       ArrayList<WeightedRule> ruleList)
  {
    Object wt = evaluate(wtExp);
    if( wt instanceof Number )
      {
        Double weight = ((Number) wt).doubleValue();
        if( weight >= 0 )
          {
            ruleList.add(new WeightedRule(lhs, rhs, weight));
          }
      }
    else
      {
        ErrorLog.log(ErrorLog.WARNING, "Invalid weight expression in grammar rule: " + wtExp);
      }
  }

/**
 * Pop tokens off the stack stack. Any terminal tokens are pushed onto
 * accumulator. Rules are applied to non-terminals.
 */
public Polylist applyRules(Polylist stack) throws RuleApplicationException
  {
    Object token = stack.first();
    stack = stack.rest();

    // Accumulate any terminal values at the beginning of stack.

    while( !quotaReached && isTerminal(token) )
      {
        if( isWrappedTerminal(token) )
          {
            accumulateTerminal(((Polylist) token).first());
          }
        else
          {
            accumulateTerminal(token);
          }

        if( stack.isEmpty() || quotaReached )
          {
            return stack;
          }

        token = stack.first();
        stack = stack.rest();
      }
    
    // token is a non-terminal
     
    ArrayList<WeightedRule> ruleList = new ArrayList<WeightedRule>();
    ArrayList<WeightedRule> baseList = new ArrayList<WeightedRule>();

    // Now search through and find all rules that apply to the given start lhs.
    // Note that a start lhs can be a polylist.
    for( Polylist search = rules; search.nonEmpty(); search = search.rest() )
      {
        // Next is the next rule to compare to
        Polylist next = (Polylist) search.first();
        String type = (String) next.first();
        //System.out.println("\nnext = " + next);

        //System.out.println("matching LHS " + goal);
      /*
         * RULEs and BASEs have the following S-expression format:
         * (<keyword> (<LHS lhs>) (<RHS>) weight)
         * <keyword> can be "rule" or "base"
         * <LHS lhs> can be a string or a polylist of strings
         * <RHS> is a polylist of symbols (or if it's a RULE, some expressions
         *	to evaluate).
         * <weight> is a double expressing how "important" the rhs is.  More important
         *	rules will be chosen more often than less important ones.
         */

        // The BASE keyword stops all evalution and variable substitution.
        // If a lhs matches both a RULE and a BASE, it will always choose the BASE.
        // This basically short-circuits any computation and provides an easy way
        // to find base cases.

        if( type.equals(BASE) && next.length() == 4 )
          {
            //System.out.println("\nbase = " + next);
            Polylist lhs = (Polylist) next.second();
            Polylist rhs = (Polylist) next.third();

            if( token.equals(lhs) )
              {
                //addToList(lhs, rhs, next.fourth(), baseList);
              }
          }
        // Most objects will have type RULE.
        else if( type.equals(RULE) && next.length() == 4 )
          {
            //System.out.println("\nrule = " + next);
            Polylist lhs = (Polylist) next.second();
            Polylist rhs = (Polylist) next.third();

            //System.out.println(" rhs before evaluation  " + rhs);
            //System.out.println("token = " + token);

            if( token instanceof Polylist 
                && ((Polylist) token).first() instanceof String )
              {
                if( ((String) ((Polylist) token).first()).equals(lhs.first()) )
                  {
                    // Unify variables with their given numeric values,
                    // in preparation for evaluation.
                    rhs = setVars((Polylist) token, lhs, rhs);

                    // A null result means that unification failed.
                    if( rhs == null )
                      {
                        continue;
                      }

                    //System.out.println(" rhs after setVars " + rhs);

                    // Evaluate any expressions that need to be evaluated.
                    rhs = (Polylist) evaluate(rhs);

                    //System.out.println(" rhs after evaluation of " + token + ": " + rhs);

                    // Check for negative arguments in RHS,
                    // In which case don't use RHS
                    boolean valid = true;
                    PolylistEnum L = rhs.elements();
                    polya.PolylistBuffer B = new polya.PolylistBuffer();
                    while( L.hasMoreElements() )
                      {
                        Object ob = L.nextElement();
                        if( ob instanceof Polylist )
                          {
                            Polylist P = (Polylist) ob;

                            if( P.length() == 2 && P.first().equals(startSymbol) )
                              {
                                // We found the start lhs on the RHS.
                                // Only pass it if argument is non-negative.
                                // FIX: Replace this with a more sound mechanism.

                                Object arg = P.second();
                                if( arg instanceof Number && ((Number) arg).intValue() <= 0 )
                                  {
                                    //valid = false;
                                    //System.out.println("abandoning: " + rhs);
                                    //break;
                                  }
                                else
                                  {
                                    B.append(ob);
                                  }
                              }
                            else
                              {
                                B.append(ob);
                              }
                          }
                        else
                          {
                            B.append(ob);
                          }
                      } // while

                    rhs = B.toPolylist();

                    if( valid )
                      {
                        addToList(lhs, rhs, next.fourth(), ruleList);
                      }
                  }
              }
          }
      }

    // Give baseList priority over ruleList.
    ArrayList<WeightedRule> listToUse = baseList.isEmpty() ? ruleList : baseList;

    if( listToUse.isEmpty() )
      {
      if( traceLevel > 0 )
        {
        System.out.println("goal: " + token + "no rule found");
        }
      }
    else
      {
      // Sum up all the weights for normalization.	    
      double total = 0.0;
      for( WeightedRule weightedRule: listToUse)
        {
        total += weightedRule.getWeight();
        }
    
    // Generate a random number to find out which rule to use.
    double rand = total*Math.random();
    double offset = 0.0;

    int listSize = listToUse.size();
    
    WeightedRule ruleToUse = null;
    // Loop through all rules up to one in the probability interval,
    // the break.
    for( WeightedRule weightedRule: listToUse)
      {
        // If the random number falls between the range of the probability 
        // for that rule, we choose it and break out of the loop.
        double rule_weight = weightedRule.getWeight();
        if( rand >= offset && rand < (offset + rule_weight) )
          {
            //System.out.println("rule found");
            ruleToUse = weightedRule;
            break;
          }
        offset += rule_weight;
      }
    
    if( ruleToUse == null && listSize > 0)
      {
      // Use the last rule in the list.
      ruleToUse = listToUse.get(listSize - 1);
      }
    
    if( ruleToUse != null )
      {
        if( traceLevel > 1 )
          {
          showFrontier(stack.cons(token));
          } 
        if( traceLevel > 0 )
          {
          System.out.println(ruleToUse);
          System.out.println();
          }
      stack = ruleToUse.addToGen(stack);
      }
    }

    return stack; // throw new RuleApplicationException("applyRules, no such rule for " + stack);
  }

private void showFrontier(Polylist gen)
  {
    System.out.println("| " + terminalBuffer.toPolylist() + " | " + gen + " | ");
  }

/**
 * Load in any terminal values specified in the user file. Returns a ArrayList
 * containing all terminal values.
 */
public ArrayList<Object> getAllOfType(String t)
  {
    Polylist search = rules;
    ArrayList<Object> elements = new ArrayList<Object>();
    while( search.nonEmpty() )
      {
        try
          {
            Polylist next = (Polylist) search.first();
            String type = (String) next.first();

            if( type.equals(t) )
              {
                for( int i = 1; i < next.length(); ++i )
                  {
                    elements.add(next.nth(i));
                  }
              }
            search = search.rest();
          }
        catch( ClassCastException e )
          {
            ErrorLog.log(ErrorLog.SEVERE, "Error parsing " + t);
            return null;
          }
      }

    return elements;
  }


/**
 * Clear the parameters specified in the grammar file, for subsequent
 * replacement.
 */

public void clearParams()
  {
    Polylist newRules = Polylist.nil;

    while( rules.nonEmpty() )
      {
        if( !((String) ((Polylist) rules.first()).first()).equals(PARAM) )
          {
            newRules = newRules.cons(rules.first());
          }
        rules = rules.rest();
      }

    newRules = newRules.reverse();
    rules = newRules;
  }

public ArrayList<Polylist> getParams()
  {
    return new ArrayList<Polylist>((Collection) getAllOfType(PARAM));
  }

public Polylist addRule(Polylist toAdd)
  {
    rules = rules.cons(toAdd);
    return rules;
  }

public Polylist getRules()
  {
    return rules;
  }

// Load the rules in from a file.
public int loadGrammar(String filename)
  {
    //System.out.println("Grammar loadGrammar " + filename);
    clear();
    try
      {
        Tokenizer in = new Tokenizer(new FileInputStream(filename));
        Object ob;

        while( (ob = in.nextSexp()) != Tokenizer.eof )
          {
            //System.out.println("ob = " + ob);
            if( ob instanceof Polylist )
              {
                rules = rules.cons((Polylist) ob);
              }
          }
        rules = rules.reverse();
        //terminals = getTerminals();
        return 0;
      }
    catch( FileNotFoundException e )
      {
        ErrorLog.log(ErrorLog.SEVERE, "File " + filename + " not found.  Abort.");
        return -1;
      }
  }

public int saveGrammar(String filename)
  {
    try
      {
        Polylist toWrite = rules;
        String contents = "";
        while( toWrite.nonEmpty() )
          {
            contents += toWrite.first() + "\n";
            toWrite = toWrite.rest();
          }
        FileWriter out = new FileWriter(new File(filename));
        out.write(contents);
        out.close();
        return 0;
      }
    catch( IOException e )
      {
        ErrorLog.log(ErrorLog.WARNING, "Error saving to " + filename);
        return -1;
      }
  }

public void clear()
  {
    rules = Polylist.nil;
  }

/**
 * Set all instances of variables in toSet corresponding value in getValsFrom.
 * This is a unilateral unification.
 */
private Polylist setVars(Polylist getValsFrom,
                         Polylist getVarsFrom,
                         Polylist toSet)
  {
    // skip first element, which is a functor
    Polylist vars = getVarsFrom.rest();
    Polylist vals = getValsFrom.rest();
    while( vars.nonEmpty() && vals.nonEmpty() )
      {
        Object var = vars.first();
        Object val = vals.first();
        if( (var instanceof Number) && (val instanceof Number) )
          {
            if( ((Number) var).longValue() != ((Number) val).longValue() )
              {
                return null;  // not unifiable
              }
          }
        else if( (var instanceof String) && (val instanceof Number) )
          {
            toSet = replace(var.toString(), ((Number) val).longValue(), toSet);
          }
        else if( (var instanceof String) && (val instanceof String) )
          {
            if( !var.equals(val) )
              {
                return null;  // not unifiable  
              }
          }
        else
          {
            return null; // not unifiable
          }

        vars = vars.rest();
        vals = vals.rest();
      }
    return toSet;
  }

// Evaluate will take an object and perform arithmetic evaluation on it.
// Expressions should be given in prefix form:
// (+ 3 4) evaluates to 7
// (+ (/ 4 2) (* 7 3)) evaluates to 23
//
// As of 21 June 2012, evaluate can accept builtins, of the form
// (builtin <some identifier>)
// Right now, the only identifier is "expectancy". Evaluation of this identifier
// is stubbed to return 1. Any other identifier will return 0.
// Eventually, the value of the builtin identifier may change depending on the
// then-current slot.
private Object evaluate(Object toParse)
  {
    //System.out.println("currentSlot = " + currentSlot);
    // Base case:
    if( toParse instanceof Number || toParse instanceof String )
      {
        return toParse;
      }
    else if( toParse instanceof Polylist && ((Polylist) toParse).nonEmpty() )
      {
        try
          {
            // Recursively evaluate until we get down to two numbers we can add.
            Polylist parsing = (Polylist) toParse;

            if( BUILTIN.equals(parsing.first()) )
              {
                return evaluateBuiltin(parsing.second(), parsing.third());
              }
            else if( PLUS.equals(parsing.first()) )
              {
                return Arith.add(evaluate(parsing.second()), evaluate(parsing.third()));
              }
            else if( MINUS.equals(parsing.first()) )
              {
                return Arith.subtract(evaluate(parsing.second()), evaluate(parsing.third()));
              }
            else if( TIMES.equals(parsing.first()) )
              {
                return Arith.multiply(evaluate(parsing.second()), evaluate(parsing.third()));
              }
            else if( DIVIDE.equals(parsing.first()) )
              {
                return Arith.divide(evaluate(parsing.second()), evaluate(parsing.third()));
              }
            else
              {
                Polylist p = Polylist.nil;
                Polylist L = parsing;
                while( L.nonEmpty() )
                  {
                    p = Polylist.cons(evaluate(L.first()), p);
                    L = L.rest();
                  }
                p = p.reverse();
                return p;
              }
          }
        catch( ClassCastException e )
          {
            ErrorLog.log(ErrorLog.SEVERE, "Bad cast operation in evaluation of " + toParse);
            return null;
          }
      }
    else
      {
        return null;
      }
  }

/**
 * Evaluate the rest of a special form (splice <operator> <arg> ...) (<operator>
 * <arg> ...) must return a list. Currently the only operator available is
 * literal, e.g. a rule RHS of the form (C4 (splice literal C8 C8) (splice
 * literal C16 C16 C16 C16) R4) returns (C4 C8 C8 C16 C16 C16 C16 R4)
 *
 * It is expected that additional splice-oriented operators will be added, and
 * not all will just use literal arguments.
 *
 * @param form
 * @return
 */
Polylist evaluateSplice(Polylist form)
  {
    if( form.isEmpty() )
      {
        return Polylist.nil;
      }

    Object operator = form.first();
    Polylist args = form.rest();

    if( LITERAL.equals(operator) )
      {
        return args;
      }
    if( SYNCOPATION.equals(operator) )
      {
        MelodyPart melody = notate.getCurrentMelodyPart();
        MelodyPart currMelody = melody.extract(currentSlot - LENGTH_OF_TRADE, currentSlot);
        int[] syncVector = currMelody.getSyncVector(15, LENGTH_OF_TRADE);
        int measures = LENGTH_OF_TRADE / SLOTS_PER_MEASURE;
        int synco = Tension.getSyncopation(syncVector, measures);
        //Generates a syncopation that matches the syncopation of the previous 4 bars
        int[] rhythm = Generator.generateSyncopation(measures, synco);
        String[] rhythmArray = Generator.generateString(rhythm, (String) args.first());
        Polylist rhythmList = Polylist.PolylistFromArray(rhythmArray);
        return rhythmList;
      }
    // default

    return Polylist.nil;
  }

public int getCurrentSlot()
  {
    return currentSlot;
  }

// For testing purposes only:
int expectancyValue = 0;
int syncopationValue = 1;
private static int LENGTH_OF_TRADE = 4 * 480;
private static int SLOTS_PER_MEASURE = 480;

/**
 * Evaluates the arguments following the builtin operator. So far only
 * implemented for expectancy and syncopation
 *
 * @param arg1
 * @param arg2
 * @return
 */
private Object evaluateBuiltin(Object arg1, Object arg2)
  {
    //System.out.println("\nevaluate-builtin " + arg1 + " " + arg2);

    ChordPart chords = notate.getChordProg();
    if( arg1 instanceof String && ((String) arg1).equals(CHORD_FAMILY) )
      {
        if( !(arg2 instanceof Polylist) )
          {
            return 0;
          }

        Polylist families = (Polylist) arg2;

        Chord currentChord = chords.getCurrentChord(chordSlot);

        if( currentChord == null )
          {
            return ZERO;
          }

        return families.member(currentChord.getFamily()) ? ONE : 0.1;
      }
    // Is evaluable of the form (builtin brick <brickname>)
    if( BRICK.equals(arg1) )
      {
        //System.out.println("evaluating brick at slot " + chordSlot);
        if( !(arg2 instanceof String) )
          {
            return ZERO;
          }

        String brickname = (String) arg2;

        notate.ensureRoadmap();
        Block currentBlock = chords.getBlockAtSlot(chordSlot);

        if( currentBlock == null )
          {
            return ZERO;
          }

        String blockName = currentBlock.getDashedName();

        if( brickname.equals(blockName) )
          {
            if( traceLevel > 0 )
              {
              System.out.println("At slot " + chordSlot
                    + " considering brick " + brickname);
              }
            return ONE;
          }

        //System.out.println("At slot " + chordSlot 
        //           + " brickname " + brickname + " doesn't match " + blockName);

        return 0.1; //ZERO;
      }
    MelodyPart melody = notate.getCurrentMelodyPart();
    MelodyPart currMelody = melody.extract(currentSlot - LENGTH_OF_TRADE, currentSlot);
    if( EXPECTANCY.equals(arg1) )
      {
        int firstIndex = currMelody.getNextIndex(0);
        int secondIndex = currMelody.getNextIndex(firstIndex);
        if( currMelody.getNote(firstIndex) == null || currMelody.getNote(secondIndex) == null )
          {
            return ONE;
          }
        PartIterator pi = currMelody.iterator(secondIndex);
        int numPitches = 2;
        double totalExpectancy = 0;
        while( pi.hasNext() )
          {
            Chord c = chords.getChord(pi.nextIndex());
            int first = currMelody.getNote(firstIndex).getPitch();
            int second = currMelody.getNote(secondIndex).getPitch();
            int curr = currMelody.getNote(pi.nextIndex()).getPitch();
            double expectancy = Expectancy.getExpectancy(curr, second, first, c);
            totalExpectancy += expectancy;
            numPitches++;
            firstIndex = secondIndex;
            secondIndex = pi.nextIndex();
            pi.next();
          }
        return new Double(totalExpectancy / numPitches);
      }
    if( SYNCOPATION.equals(arg1) )
      {
        int[] syncVector = currMelody.getSyncVector(15, LENGTH_OF_TRADE);
        int synco = Tension.getSyncopation(syncVector, (LENGTH_OF_TRADE / SLOTS_PER_MEASURE));
        //System.out.println(synco);
        double syncoPerMeasure = synco / (LENGTH_OF_TRADE / SLOTS_PER_MEASURE);
        //System.out.println("Syncopation per measure " + syncoPerMeasure);
        if( arg2.equals(HIGH) )
          {
            if( syncoPerMeasure >= 8 )
              {
                //System.out.println("High");
                return new Double(0.8);
              }
            else
              {
                return new Double(0.1);
              }
          }
        if( arg2.equals(MEDIUM) )
          {
            if( syncoPerMeasure < 8 && syncoPerMeasure >= 4 )
              {
                //System.out.println("Medium");
                return new Double(0.8);
              }
            else
              {
                return new Double(0.1);
              }
          }
        if( arg2.equals(LOW) )
          {
            if( syncoPerMeasure < 4 )
              {
                //System.out.println("Low");
                return new Double(0.8);
              }
            else
              {
                return new Double(0.1);
              }
          }
        return ZERO;
      }
    return ZERO;
  }

// Recursively replace all instances of varName with value in toReplace
private Polylist replace(String varName, Long value, Polylist toReplace)
  {
    Polylist toReturn = Polylist.nil;

    Polylist L = toReplace;

    while( L.nonEmpty() )
      {
        if( L.first() instanceof Polylist )
          {
            toReturn = toReturn.cons(replace(varName, value, (Polylist) L.first()));
          }
        else if( varName.equals(L.first()) )
          {
            toReturn = toReturn.cons(value);
          }
        else
          {
            toReturn = toReturn.cons(L.first());
          }
        L = L.rest();
      }
    //System.out.println("replace var " + varName + " with " + value + " in " + toReplace + " giving " + toReturn.reverse());
    return toReturn.reverse();
  }

/**
 * Inner class representation of rules with weights, for probabilistic evaluation.
 */
class WeightedRule
{
Polylist lhs;
Polylist rhs;
double weight;

WeightedRule(Polylist lhs, Polylist rhs, double weight)
  {
    this.lhs = lhs;
    this.rhs = rhs;
    this.weight = weight;
  }

Polylist getRHS()
  {
    return rhs;
  }

double getWeight()
  {
    return weight;
  }

Polylist addToGen(Polylist gen)
  {
    boolean onlyTerminalsSoFar = true;
    PolylistBuffer afterFirstTerminals = new PolylistBuffer();
    
    for( Polylist L = rhs; L.nonEmpty(); L = L.rest() )
      {
        Object next = L.first();
        if( onlyTerminalsSoFar && isTerminal(next) )
          {
            accumulateTerminal(next);
          }
        else
          {
          onlyTerminalsSoFar = false;
          if( next instanceof Polylist )
            {
            afterFirstTerminals.append(next);
            }
          else
            {
            afterFirstTerminals.append(Polylist.list(next));
            }
          }
      }
    return afterFirstTerminals.toPolylist().append(gen);
  }

@Override
public String toString()
  {
  return lhs + " -> " + rhs + " [prob " + weight +"]";
  }

}
}
